
### Link

https://leetcode.com/problems/min-stack/

### Clarifications / Constraints

1. 

### Idea_1

1. 


#### Code

```java
class MinStack {
    Deque<int[]> stack;
    int min;
    public MinStack() {
        stack = new LinkedList<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int val) {
        min = Math.min(min, val);
        stack.push(new int[]{val, min});
    }
    
    public void pop() {
        stack.pop();
        if (stack.isEmpty()) min = Integer.MAX_VALUE;
        else min = stack.peek()[1];
    }
    
    public int top() {
        return stack.peek()[0];
    }
    
    public int getMin() {
        return stack.peek()[1];
    }
}

```

#### Complexity

Time Complexity : O(1) for all operations.

push(...): Checking the top of a Stack, comparing numbers, and pushing to the top of a Stack (or adding to the end of an Array or List) are all O(1) operations. Therefore, this overall is an O(1) operation.

pop(...): Popping from a Stack (or removing from the end of an Array, or List) is an O(1) operation.

top(...): Looking at the top of a Stack is an O(1) operation.

getMin(...): Same as above. This operation is O(1) because we do not need to compare values to find it. If we had not kept track of it on the Stack, and instead had to search for it each time, the overall time complexity would have been O(n).

Space Complexity : O(n).

Worst case is that all the operations are push. In this case, there will be O(2â‹…n)=O(n) space used.

